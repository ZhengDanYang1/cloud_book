# 第7节：服务无状态化

状态化的判断是指两个来自相同发起者的请求在服务器端是否具备上下文关系。如果是状态化请求，那么服务器端一般都要保存请求的相关信息，每个请求可以默认地使用以前的请求信息。而无状态请求则不行，服务器端所能够处理的过程，他的处理信息必须全部来自于请求所携带的信息以及其他服务器端自身所保存的、并且可以被所有请求所使用的公共信息。

无状态服务是指该服务运行的实例不会在本地存储需要持久化的数据，并且多个实例对于同一个请求响应的结果是完全一致的。当访问该服务的请求到达服务一端后，负载均衡会随机找到一个实例来完成该请求的响应（目前为轮询）。这类服务的实例可能会因为一些原因停止或者重新创建（如扩容时），这时，这些停止的实例里的所有信息（除日志和监控数据外）都将丢失(重启容器即会丢失)。

在云原生框架中，很多应用拆分成微服务是为了承载高并发，往往一个进程无法承载，因而需要拆分成多组进程。其中每组进程完成特定的工作，根据并发的压力用多个副本公共承担流量。将一个进程变成多组进程，每组进程多个副本，需要程序的修改支撑这种分布式的架构，如果架构不支持，仅仅在资源层创建多个副本是解决不了问题的。而阻碍单体架构变为分布式架构的关键点就在于状态的处理。如果状态全部保存在本地，无论是本地的内存，还是本地的硬盘，都会给架构的横向扩展带来瓶颈。

状态分为分发、处理、存储几个过程，如果对于一个用户的所有的信息都保存在一个进程中，则从分发阶段，就必须将这个用户分发到这个进程，否则无法对这个用户进行处理，然而当一个进程压力很大的时候，根本无法扩容，新启动的进程根本无法处理那些保存在原来进程的用户的数据，不能分担压力。要将业务逻辑的部分设计成无状态的，这样无状态的部分可以很容易的横向扩展，在用户分发的时候，可以很容易分发到新的进程进行处理，而状态保存到后端。